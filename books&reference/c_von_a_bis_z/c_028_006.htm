<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: C von A bis Z – 28.7 Cross-Plattform-Development</title>
<meta name="title" content="Galileo Computing :: C von A bis Z">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Galileo Press 2006">
<meta name="copyright" content="Galileo Press 2006">
<meta name="description" content="C von A bis Z - Das umfassende Handbuch f&uuml;r Linux, Unix und Windows – 2., aktualisierte und erweiterte Auflage 2006, geb., mit CD und Referenzkarte – ISBN 3-89842-643-2">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href="c_028_005.htm">
<link rel="next" href="c_028_007.htm"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
    <table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
        <tr>
            <td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
            <td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opc"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger." title="Galileo Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a></td>
        </tr>
    </table>
    <div align="right"><a href="http://www.galileocomputing.de/?GPP=opc" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger.</a></div>
    <br />
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td width="156" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
        <tr>
            <td colspan="2" class="nav1" align="left" valign="top" height="150">
                <table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><a class="nav" href="./index.htm">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="./c_000Vorwort_000.htm#Xxx999266">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="./c_000VorwortGutachter_000.htm#Xxx999275">Vorwort des Gutachters</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_001_000.htm#Xxx999328">1 Einstieg in C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_002_000.htm#Xxx999328">2 Das erste Programm</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_003_000.htm#Xxx999328">3 Zeichens&auml;tze</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_004_000.htm#Xxx999329">4 Kommentare in C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_005_000.htm#Xxx999330">5 Formatierte Eingabe mit scanf()</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_006_000.htm#Xxx999330">6 Formatierte Ausgabe mit printf</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_007_000.htm#Xxx999329">7 Elementare Datentypen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_008_000.htm#Xxx999328">8 Operatoren</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_009_000.htm#Xxx999328">9 Typenumwandlung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_010_000.htm#Xxx999328">10 Kontrollstrukturen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_011_000.htm#Xxx999328">11 Funktionen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_012_000.htm#Xxx999328">12 Pr&auml;prozessor-Direktiven</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_013_000.htm#Xxx999328">13 Arrays</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_014_000.htm#Xxx999328">14 Zeiger (Pointer)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_015_000.htm#Xxx999328">15 Kommandozeilenargumente</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_016_000.htm#Xxx999328">16 Dynamische Speicherverwaltung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_017_000.htm#Xxx999328">17 Strukturen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_018_000.htm#Xxx999328">18 Ein-/Ausgabe-Funktionen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_019_000.htm#Xxx999328">19 Attribute von Dateien und Arbeiten mit Verzeichnissen (nicht ANSI C)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_020_000.htm#Xxx999328">20 Arbeiten mit variablen langen Argumentlisten – &lt;stdarg.h&gt;</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_021_000.htm#Xxx999328">21 Zeitroutinen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_022_000.htm#Xxx999328">22 Weitere Headerdateien und ihre Funktionen (ANSI C)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_023_000.htm#Xxx999328">23 Dynamische Datenstrukturen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_024_000.htm#Xxx999328">24 Algorithmen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_025_000.htm#Xxx999328">25 Sicheres Programmieren</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_026_000.htm#Xxx999328">26 CGI mit C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_027_000.htm#Xxx999328">27 MySQL und C</A></td>
</tr>
<tr>
<td><A class="navh" href="./c_028_000.htm#Xxx999328">28 Netzwerkprogrammierung und Cross-Plattform-Entwicklung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_029_000.htm#Xxx999328">29 Wie geht’s jetzt weiter?</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_030Anhang_000.htm#Xxx999266">A Anhang</A></td>
</tr>
<tr>
<td><a class="navnav" href="./stichwort.htm#Xxx512322">Index</a></td>
</tr>
<tr><td><br /><a class="navnav" href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip"><strong>Download:</strong><br />- ZIP, ca. 8,5 MB</a></td></tr>
<tr><td><a class="navnav" href="http://www.galileocomputing.de/899?GPP=opc">Buch bestellen</a></td></tr>
<tr><td><a class="navnav" href="mailto:stefan.krumbiegel@galileo-press.de?subject=Meinung%20zu%20C%20von%20A%20bis%20Z%20(openbook)">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
    <div align="center">
        <table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
            <tr>
                <td width="100%" class="start" colspan="1" height="22" align="center">
                    <table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a class="navnav" href="c_028_005.htm"> &lt;&lt; zur&uuml;ck</a></td>
<td width="49%">
<div align="center"><a href="http://www.galileocomputing.de/?GPP=opc" class="navnav">Galileo Computing /</a><a class="navnav" href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc"> &lt;openbook&gt; /</a><a href="./index.htm" class="navnav"> C von A bis Z</a></div>
</td>
<td align="right" width="25%">
<div align="right"><a class="navnav" href="c_028_007.htm">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
    <table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
        <tr>
            <td colspan="2"><a href="http://www.galileocomputing.de/899?GPP=opc" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch f&uuml;r Linux, Unix und Windows <br />– 2., aktualisierte und erweiterte Auflage 2006</span></td>
        </tr>
        <tr>
            <td valign="top" width="90"><a href="http://www.galileocomputing.de/899?GPP=opc"><img src="common/643.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z" align="left"><br /><br /><span class="autor"><strong>C von A bis Z</strong><br />1.116 S., mit CD, Referenzkarte, 39,90 Euro<br />Galileo Computing<br />ISBN 3-89842-643-2</span></a></a></td>
            <td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="./c_028_000.htm#RxxobKap02800004002D021F04318C">28 Netzwerkprogrammierung und Cross-Plattform-Entwicklung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F043192">28.1 Begriffe zur Netzwerktechnik</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F043194">28.1.1 IP-Nummern</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F04319E">28.1.2 Portnummer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F0431A2">28.1.3 Host- und Domainname</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F0431A6">28.1.4 Nameserver</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F0431A8">28.1.5 Das IP-Protokoll</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F0431AC">28.1.6 TCP und UDP</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_000.htm#RxxobKap02800004002D021F0431B2">28.1.7 Was sind Sockets?</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_001.htm#RxxobKap02800104002D1D1F01518C">28.2 Headerdateien zur Socketprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_001.htm#RxxobKap02800104002D1D1F01518E">28.2.1 Linux/UNIX</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_001.htm#RxxobKap02800104002D1D1F015193">28.2.2 Windows</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_002.htm#RxxobKap02800204002D1E1F02A18C">28.3 Client-/Server-Prinzip</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_002.htm#RxxobKap02800204002D1E1F02A190">28.3.1 Loopback-Interface</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_003.htm#RxxobKap02800304002D1F1F03918C">28.4 Erstellen einer Client-Anwendung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_003.htm#RxxobKap02800304002D1F1F03918E">28.4.1 socket() – Erzeugen eines Kommunikationsendpunktes</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_003.htm#RxxobKap02800304002D1F1F0391AC">28.4.2 connect() – Client stellt Verbindung zum Server her</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_003.htm#RxxobKap02800304002D1F1F0391DA">28.4.3 Senden und Empfangen von Daten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_003.htm#RxxobKap02800304002D1F1F0391F3">28.4.4 close(), closesocket()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_004.htm#RxxobKap02800404002D201F01818C">28.5 Erstellen einer Server-Anwendung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_004.htm#RxxobKap02800404002D201F01818E">28.5.1 bind() – Festlegen einer Adresse aus dem Namensraum</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_004.htm#RxxobKap02800404002D201F018199">28.5.2 listen() – Warteschlange f&uuml;r eingehende Verbindungen einrichten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_004.htm#RxxobKap02800404002D201F0181A2">28.5.3 accept() und die Serverhauptschleife</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_005.htm#RxxobKap02800504002D211F04918C">28.6 (Cross-Plattform)TCP-Echo-Server</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_005.htm#RxxobKap02800504002D211F04918E">28.6.1 Der Client</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_005.htm#RxxobKap02800504002D211F049191">28.6.2 Der Server</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh" href="#RxxobKap02800604002D221F02418C">28.7 Cross-Plattform-Development</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F02418E">28.7.1 Abstraktion Layer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F024190">28.7.2 Headerdatei Linux/UNIX</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F024192">28.7.3 Linux/UNIX-Quelldatei</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F024196">28.7.4 Headerdatei MS-Windows</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F024198">28.7.5 Windows-Quelldatei</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F02419A">28.7.6 All together – die main-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F0241AE">28.7.7 Ein UDP-Beispiel</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap02800604002D221F0241BA">28.7.8 Mehrere Clients gleichzeitig behandeln</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F02218C">28.8 Weitere Anmerkungen zur Netzwerkprogrammierung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F02218E">28.8.1 Das Datenformat</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F022193">28.8.2 Der Puffer</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F022199">28.8.3 Portabilit&auml;t</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F02219B">28.8.4 Von IPv4 nach IPv6</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F0221AA">28.8.5 RFC-Dokumente (Request for Comments)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_028_007.htm#RxxobKap02800704002D231F0221AC">28.8.6 Sicherheit</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2">28.7 Cross-Plattform-Development<a id="RxxobKap02800604002D221F02418C" name="RxxobKap02800604002D221F02418C"></a> 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<p>Das kleine Beispiel des TCP-Echo-Servers zeigte Ihnen einen einfachen Weg, wie Sie mit einfachen <span class="listing">#ifdef</span> Pr&auml;prozessor-Direktiven eine Cross-Plattform-Anwendung schreiben k&ouml;nnen. Das Problem dabei allerdings (am Quellcode) war, dass alles f&uuml;r jede Plattform in eine Datei geschrieben wurde. F&uuml;r das kleine Programm ist das zwar nicht die Rede wert, aber bei umfangreicheren und komplizierten Programmen ist es sinnvoller, einen abstrakten Layer (Abstraktion Layer) zu schreiben. Nicht anders wird dies &uuml;brigens bei solchen Mammut-Projekten wie MySQL und dem Apache realisiert – auch hier finden Sie f&uuml;r alle g&auml;ngigen Plattformen eine extra Version.</p>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3">28.7.1 Abstraktion Layer<a id="RxxobKap02800604002D221F02418E" name="RxxobKap02800604002D221F02418E"></a> 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999331" name="Xxx999331"></a>Hinter diesem Begriff verbirgt sich nichts Kompliziertes. Der Abstraktion Layer isoliert Plattform-spezifische Funktionen und Datentypen in separate Module f&uuml;r portablen Code. Die Plattform-spezifischen Module werden dann speziell f&uuml;r jede Plattform geschrieben. Des Weiteren erstellen Sie eine neue Headerdatei, in der sich eventuell die Plattform-spezifischen <span class="listing">typedef</span>’s und <span class="listing">#define</span>’s mitsamt den Funktionsprototypen der Module befinden. Bei der Anwendung selbst binden Sie nur noch diese Headerdatei ein. Auf den folgenden Seiten finden Sie nun die einzelnen Quellcodes f&uuml;r unseren abstrakten Layer – ich werde diesen einfach SOCKETPRX nennen.</p>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3">28.7.2 Headerdatei Linux/UNIX<a id="RxxobKap02800604002D221F024190" name="RxxobKap02800604002D221F024190"></a> 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<pre>/* socketprx.h f&uuml;r Linux/UNIX */
#ifndef SOCKETPRX_H_
#define SOCKETPRX_H_
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
/* Ein eigener primitver Datentyp f&uuml;r den Socket-Deskriptor */
#define socket_t int
/* Funktionsprototypen */
void error_exit(char *error_message);
int create_socket( int af, int type, int protocol );
void bind_socket(socket_t 
  *sock, unsigned long adress, unsigned short port);
void listen_socket( socket_t *sock );
void accept_socket( socket_t *new_socket, socket_t *socket );
void connect_socket(socket_t *sock, char *serv_addr,
 unsigned short port);
void TCP_send( socket_t *sock, char *data, size_t size);
void TCP_recv( socket_t *sock, char *data, size_t size);
void UDP_send ( socket_t *sock, char *data, size_t size, 
  char *addr, unsigned short port);
void UDP_recv( socket_t *sock, char *data, size_t size);
void close_socket( socket_t *sock );
void cleanup(void);
#endif</pre>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3">28.7.3 Linux/UNIX-Quelldatei<a id="RxxobKap02800604002D221F024192" name="RxxobKap02800604002D221F024192"></a> 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<pre>/* socketlayer.c – f&uuml;r Linux/UNIX */
#include  "socketprx.h"
/* Funktion gibt aufgetretene Fehler aus und
 * beendet die Anwendung */
void error_exit(char *error_message) {
    fprintf(stderr, "%s: %s\n", error_message, strerror(errno));
    exit(EXIT_FAILURE);
}
 int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    const int y = 1;
    /* Erzeuge das Socket */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Socket");
    /* Mehr dazu siehe Anmerkung am Ende des Listings ... */
    setsockopt( sock, SOL_SOCKET,
                SO_REUSEADDR, &amp;y, sizeof(int));
    return sock;
}
/* Erzeugt die Bindung an die Serveradresse
 * (genauer an einen bestimmten Port) */
void bind_socket(socket_t *sock, unsigned long adress,
                 unsigned short port) {
   struct sockaddr_in server;
   memset( &amp;server, 0, sizeof (server));
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(adress);
   server.sin_port = htons(port);
   if (bind(*sock, (struct sockaddr*)&amp;server,sizeof(server)) &lt; 0)
       error_exit("Kann das Socket nicht \"binden\"");
}
/* Teile dem Socket mit, dass Verbindungsw&uuml;nsche
 * von Clients entgegengenommen werden */
void listen_socket( socket_t *sock ) {
  if(listen(*sock, 5) == –1 )
      error_exit("Fehler bei listen");
}
/* Bearbeite die Verbindungsw&uuml;nsche von Clients
 * Der Aufruf von accept() blockiert solange,
 * bis ein Client Verbindung aufnimmt */
void accept_socket( socket_t *socket, socket_t *new_socket ){
   struct sockaddr_in client;
   int len;
   len = sizeof(client);
   *new_socket=accept(*socket,(struct sockaddr *)&amp;client, &amp;len);
   if (*new_socket  == –1)
      error_exit("Fehler bei accept");
}
/* Baut die Verbindung zum Server auf */
void connect_socket(socket_t *sock, char *serv_addr,
                    unsigned short port) {
   struct sockaddr_in server;
   struct hostent *host_info;
   unsigned long addr;
   memset( &amp;server, 0, sizeof (server));
   if ((addr = inet_addr( serv_addr )) != INADDR_NONE) {
       /* argv[1] ist eine numerische IP-Adresse */
       memcpy( (char *)&amp;server.sin_addr, &amp;addr, sizeof(addr));
   }
   else {
       /* F&uuml;r den Fall der F&auml;lle: Wandle den
        * Servernamen bspw. "localhost" in eine IP-Adresse um */
       host_info = gethostbyname( serv_addr );
       if (NULL == host_info)
           error_exit("Unbekannter Server");
       memcpy( (char *)&amp;server.sin_addr, host_info-&gt;h_addr,
               host_info-&gt;h_length);
   }
   server.sin_family = AF_INET;
   server.sin_port = htons( port );
   /* Baue die Verbindung zum Server auf */
   if (connect(
         *sock, (struct sockaddr *)&amp;server, sizeof( server)) &lt; 0)
      error_exit( "Kann keine Verbindung zum Server herstellen");
}
/* Daten versenden via TCP */
void TCP_send( socket_t *sock, char *data, size_t size) {
   if(send( *sock, data, size, 0) == –1 )
      error_exit("Fehler bei send()");
}
/* Daten empfangen via TCP */
void TCP_recv( socket_t *sock, char *data, size_t size) {
    int len;
    len = recv (*sock, data, size, 0);
    if( len &gt; 0 || len != –1 )
       data[len] = '\0';
    else
       error_exit("Fehler bei recv()");
}
/* Daten senden via UDP */
void UDP_send ( socket_t *sock, char *data, size_t size,
                char *addr, unsigned short port){
  struct sockaddr_in addr_sento;
  struct hostent *h;
  int rc;
  /* IP-Adresse vom Server &uuml;berpr&uuml;fen */
  h = gethostbyname(addr);
  if (h == NULL)
     error_exit("Unbekannter Host?");
  addr_sento.sin_family = h-&gt;h_addrtype;
  memcpy ( (char *) &amp;addr_sento.sin_addr.s_addr,
           h-&gt;h_addr_list[0], h-&gt;h_length);
  addr_sento.sin_port = htons (port);
  rc = sendto(*sock, data, size, 0,
                 (struct sockaddr *) &amp;addr_sento,
                 sizeof (addr_sento));
  if (rc &lt; 0)
     error_exit("Konnte Daten nicht senden – sendto()");
}
/* Daten empfangen via UDP */
void UDP_recv( socket_t *sock, char *data, size_t size){
   struct sockaddr_in addr_recvfrom;
   int len;
   int n;
   len = sizeof (addr_recvfrom);
   n = recvfrom ( *sock, data, size, 0,
                   (struct sockaddr *) &amp;addr_recvfrom, &amp;len );
   if (n &lt; 0) {
       printf ("Keine Daten empfangen ...\n");
       return;
    }
}
/* Socket schlie&szlig;en */
void close_socket( socket_t *sock ){
    close(*sock);
}
/* Unter Linux/UNIX nichts zu tun ... */
void cleanup(void){
   printf("Aufraeumarbeiten erledigt ...\n");
   return;
}</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>In diesem Beispiel zu Linux/UNIX wurde die Funktion <span class="listing">setsockopt()</span> verwendet. Durch die Verwendung von der symbolischen Konstante <span class="listing">SO_REUSEADDR</span> stellen Sie das Socket so ein, damit es erlaubt ist, dass mehrere Prozesse (Clients) denselben Port teilen – sprich: Mehrere Clients k&ouml;nnen innerhalb k&uuml;rzester Zeit mit dem Server in Verbindung treten. Au&szlig;erdem l&ouml;sen Sie damit auch das Problem, dass der Server beim Neustart seinen lokalen Port erst nach zwei Minuten Wartezeit wieder benutzen kann. </p>
</td>
</tr>
</table><br>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3">28.7.4 Headerdatei MS-Windows<a id="RxxobKap02800604002D221F024196" name="RxxobKap02800604002D221F024196"></a> 
      <a href="#t2t36"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<pre>/* socketprx.h f&uuml;r MS-Windows */
#ifndef SOCKETPRX_H_
#define SOCKETPRX_H_
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;winsock.h&gt;
#include &lt;io.h&gt;
#define socket_t SOCKET
void error_exit(char *error_message);
int create_socket( int af, int type, int protocol );
void bind_socket(socket_t *sock, unsigned long adress, 
  unsigned short port);
void listen_socket( socket_t *sock );
void accept_socket( socket_t *new_socket, socket_t *socket );
void connect_socket(socket_t *sock, char *serv_addr, 
  unsigned short port);
void TCP_send( socket_t *sock, char *data, size_t size);
void TCP_recv( socket_t *sock, char *data, size_t size);
void UDP_send (socket_t *sock, char *data, size_t size);
void UDP_recv( socket_t *sock, char *data, size_t size, 
  char *addr, unsigned short port);
void close_socket( socket_t *sock );
void cleanup(void);
#endif</pre>
<a name="t35"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t36"></a><h3 class="t3">28.7.5 Windows-Quelldatei<a id="RxxobKap02800604002D221F024198" name="RxxobKap02800604002D221F024198"></a> 
      <a href="#t2t37"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t35"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<pre>/* socketlayer.c – f&uuml;r MS-Windows */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;winsock.h&gt;
#include &lt;io.h&gt;
#define socket_t SOCKET
/* Funktion gibt aufgetretene Fehler aus und
 * beendet die Anwendung */
void error_exit(char *error_message) {
    fprintf(stderr,"%s: %d\n", error_message, WSAGetLastError());
    exit(EXIT_FAILURE);
}
/* Initialisiere TCP f&uuml;r Windows ("winsock"),
 * legt ein Socket an,
 * und gibt das Socket als R&uuml;ckgabewert zur&uuml;ck */
int create_socket( int af, int type, int protocol ) {
    socket_t sock;
    WORD wVersionRequested;
    WSADATA wsaData;
    wVersionRequested = MAKEWORD (1, 1);
    if (WSAStartup (wVersionRequested, &amp;wsaData) != 0)
        error_exit( "Fehler beim Initialisieren von Winsock");
    else
        printf("Winsock initialisiert\n");
    /* Erzeuge das Socket */
    sock = socket(af, type, protocol);
    if (sock &lt; 0)
        error_exit("Fehler beim Anlegen eines Socket");
    return sock;
}
/* Erzeugt die Bindung an die Serveradresse
 * (genauer an einen bestimmten Port) */
void bind_socket(socket_t *sock, unsigned long adress,
                 unsigned short port) {
   struct sockaddr_in server;
   memset( &amp;server, 0, sizeof (server));
   server.sin_family = AF_INET;
   server.sin_addr.s_addr = htonl(adress);
   server.sin_port = htons(port);
   if (bind(*sock, (struct sockaddr*) &amp;server,
          sizeof( server)) == SOCKET_ERROR)
       error_exit("Kann das Socket nicht \"binden\"");
}
/* Teile dem Socket mit, dass Verbindungsw&uuml;nsche
 * von Clients entgegengenommen werden */
void listen_socket( socket_t *sock ) {
  if(listen(*sock, 5) == –1 )
      error_exit("Fehler bei listen");
}
/* Bearbeite die Verbindungsw&uuml;nsche von Clients
 * Der Aufruf von accept() blockiert solange,
 * bis ein Client Verbindung aufnimmt */
void accept_socket( socket_t *socket, socket_t *new_socket ){
   struct sockaddr_in client;
   int len;
   len = sizeof(client);
   *new_socket=accept(*socket, (struct sockaddr *)&amp;client, &amp;len);
   if (*new_socket == INVALID_SOCKET)
      error_exit("Fehler bei accept");
}
/* Baut die Verbindung zum Server auf */
void connect_socket( socket_t *sock, char *serv_addr,
                     unsigned short port) {
   struct sockaddr_in server;
   struct hostent *host_info;
   unsigned long addr;
   memset( &amp;server, 0, sizeof (server));
   if ((addr = inet_addr( serv_addr )) != INADDR_NONE) {
       /* argv[1] ist eine numerische IP-Adresse */
       memcpy( (char *)&amp;server.sin_addr, &amp;addr, sizeof(addr));
   }
   else {
       /* F&uuml;r den Fall der F&auml;lle: Wandle den
        * Servernamen bspw. "localhost" in eine IP-Adresse um */
       host_info = gethostbyname( serv_addr );
       if (NULL == host_info)
           error_exit("Unbekannter Server");
       memcpy( (char *)&amp;server.sin_addr, host_info-&gt;h_addr,
                host_info-&gt;h_length);
   }
   server.sin_family = AF_INET;
   server.sin_port = htons( port );
   /* Baue die Verbindung zum Server auf */
   if (connect(
         *sock, (struct sockaddr*)&amp;server, sizeof( server)) &lt; 0)
      error_exit( "Kann keine Verbindung zum Server herstellen");
}
/* Daten versenden via TCP */
void TCP_send( socket_t *sock, char *data, size_t size ) {
   if( send (*sock, data, size, 0) == SOCKET_ERROR )
      error_exit("Fehler bei send()");
}
/* Daten empfangen via TCP */
void TCP_recv( socket_t *sock, char *data, size_t size) {
    int len;
    len = recv (*sock, data, size, 0);
    if( len &gt; 0 || len != SOCKET_ERROR )
       data[len] = '\0';
    else
       error_exit("Fehler bei recv()");
}
/* Daten senden via UDP */
void UDP_send ( socket_t *sock, char *data, size_t size,
                char *addr, unsigned short port){
  struct sockaddr_in addr_sento;
  struct hostent *h;
  int rc;
  /* IP-Adresse vom Server &uuml;berpr&uuml;fen */
  h = gethostbyname(addr);
  if (h == NULL)
     error_exit("Unbekannter Host?");
  addr_sento.sin_family = h-&gt;h_addrtype;
  memcpy ( (char *) &amp;addr_sento.sin_addr.s_addr,
           h-&gt;h_addr_list[0], h-&gt;h_length);
  addr_sento.sin_port = htons (port);
  rc = sendto(*sock, data, size, 0,
                 (struct sockaddr *) &amp;addr_sento,
                 sizeof (addr_sento));
  if (rc == SOCKET_ERROR)
     error_exit("Konnte Daten nicht senden – sendto()");
}
/* Daten empfangen via UDP */
void UDP_recv( socket_t *sock, char *data, size_t size){
   struct sockaddr_in addr_recvfrom;
   int len;
   int n;
   len = sizeof (addr_recvfrom);
   n = recvfrom ( *sock, data, size, 0,
                   (struct sockaddr *) &amp;addr_recvfrom, &amp;len );
   if (n == SOCKET_ERROR)
      error_exit("Fehler bei recvfrom()");
}
/* Socket schlie&szlig;en und Winsock freigeben */
void close_socket( socket_t *sock ){
    closesocket(*sock);
}
void cleanup(void){
   /* Cleanup Winsock */
   WSACleanup();
   printf("Aufr&auml;umarbeiten erledigt ...\n");
}</pre>
<a name="t36"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t37"></a><h3 class="t3">28.7.6 All together – die main-Funktionen<a id="RxxobKap02800604002D221F02419A" name="RxxobKap02800604002D221F02419A"></a> 
      <a href="#t2t38"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t36"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Nachdem Ihnen nun zwei Versionen von SOCKETPRX zur Verf&uuml;gung stehen, k&ouml;nnen Sie die Module jetzt auf dem System Ihrer Wahl &uuml;bersetzen und ausf&uuml;hren. Der Vorteil, Sie ben&ouml;tigen nur noch eine Hauptfunktion – alle Plattform-spezifischen Eigenheiten verstecken sich ja nun hinter dem Layer. Und noch ein weiterer Vorteil, bei einer guten Planung des Layers gestaltet sich die Erstellung der <span class="listing">main()</span>-Funktion erheblich leichter und k&uuml;rzer – da Sie die Fehler&uuml;berpr&uuml;fungen nun auch dem Layer &uuml;berlassen k&ouml;nnen. Besonders bezahlt macht sich ein solcher Layer, wenn Sie einzelne Routinen immer wieder ben&ouml;tigen. Somit k&ouml;nnen Sie eine tolle und simple Cross-Plattform-Bibliothek anbieten.</p>
<h4 class="t4">Der Server</h4>
<p>Das Beispiel des TCP-Echo-Servers wurde hier erweitert. Daraus ist nun eine Art 1:1-Chat zwischen dem Server und Client geworden (wie Sie mehr als einen Client bearbeiten k&ouml;nnen, erfahren Sie noch). Der Server »lauscht« am Port 15000 und wartet, bis ein Client mit diesem in Verbindung tritt. Sobald ein Client eine Verbindung zum Server hergestellt hat, k&ouml;nnen Sie (der Server) dem Client eine Zeichenkette als Nachricht senden. Anschlie&szlig;end wartet der Server auf eine Antwort vom Client. Sendet der Client dem Server die Textfolge »quit«, so bedeutet dies f&uuml;r den Server, dass der Client »aufgelegt« hat und der Server wartet wieder (mittels <span class="listing">accept()</span>) auf eine Verbindungsanfrage eines Clients. Hier der Quellcode des Servers:</p>
<pre>/* server.c */
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
int main (void) {
  socket_t sock1, sock2;
  int addrlen;
  char *buffer = (char*) malloc (BUF);
  sock1 = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  bind_socket( &amp;sock1, INADDR_ANY, 15000 );
  listen_socket (&amp;sock1);
  addrlen = sizeof (struct sockaddr_in);
  while (1) {
     accept_socket( &amp;sock1, &amp;sock2 );
     do {
        printf ("Nachricht zum Versenden: ");
        fgets (buffer, BUF, stdin);
        TCP_send (&amp;sock2, buffer, strlen (buffer));
        TCP_recv (&amp;sock2, buffer, BUF-1);
        printf ("Nachricht empfangen: %s\n", buffer);
     } while (strcmp (buffer, "quit\n") != 0);
     close_socket (&amp;sock2);
  }
  close_socket (&amp;sock1);
  return EXIT_SUCCESS;
}</pre>
<h4 class="t4">Der Client</h4>
<p>Der Quellcode des Clients ist &auml;hnlich simpel aufgebaut. Dieser versucht zun&auml;chst eine  Verbindung zum Server aufzubauen. Ist dies gegl&uuml;ckt, wartet dieser zun&auml;chst auf eine Antwort vom Server. Schickt der Server dem Client eine Antwort, so wird diese auf die Standardausgabe ausgegeben. Jetzt ist der Client an der Reihe, dem Server eine Zeichenkette zu senden. Geben Sie hierf&uuml;r »quit« an, beendet sich die Client-Anwendung und nimmt alle Aufr&auml;umarbeiten vor. Dass die Aufr&auml;umarbeiten (die Funktion <span class="listing">cleanup()</span>) durchgef&uuml;hrt werden, haben Sie mit Standard-Funktion <span class="listing">atexit()</span> sichergestellt, welche beim Beenden des Prozesses die Funktion <span class="listing">cleanup()</span> aufruft (was unter Linux/UNIX unbedeutend ist). Solch ein Cleanup wird generell gerne in dieser Form verwendet. Selbiges Cleanup wird &uuml;brigens auch beim Server eingerichtet und durchgef&uuml;hrt, sofern sich dieser beendet.</p>
<p>Ansonsten findet ein reger Kommunikationsaustausch zwischen Server und Client statt. Hier der Quellcode f&uuml;r den Client.</p>
<pre>/* client.c */
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
int main (int argc, char **argv) {
  socket_t sock;
  char *buffer = (char *)malloc (BUF);
  if( argc &lt; 2 ){
     printf("Usage: %s ServerAdresse\n", *argv);
     exit(EXIT_FAILURE);
  }
  sock = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  connect_socket(&amp;sock, argv[1], 15000);
  do {
      buffer[0] = '\0';
      TCP_recv (&amp;sock, buffer, BUF-1);
      printf ("Nachricht erhalten: %s\n", buffer);
      printf ("Nachricht zum Versenden: ");
      fgets (buffer, BUF, stdin);
      TCP_send (&amp;sock, buffer, strlen (buffer));
  } while (strcmp (buffer, "quit\n") != 0);
  close_socket (&amp;sock);
  return EXIT_SUCCESS;
}</pre>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Vergessen Sie beim &Uuml;bersetzen nicht die Datei <span class="listing">socketlayer.c</span> hinzuzulinken!</p>
</td>
</tr>
</table><br>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_06.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_06.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.6   
    </b>Client-Anwendung unter MS-Windows bei der Ausf&uuml;hrung</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_07.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_07.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.7   
    </b>Server-Anwendung unter MS-Windows bei der Ausf&uuml;hrung</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_08.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_08.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.8   
    </b>Client-Anwendung unter Linux bei der Ausf&uuml;hrung</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_09.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_09.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.9   
    </b>Server-Anwendung unter Linux bei der Ausf&uuml;hrung</p>
<a name="t37"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t38"></a><h3 class="t3">28.7.7 Ein UDP-Beispiel<a id="RxxobKap02800604002D221F0241AE" name="RxxobKap02800604002D221F0241AE"></a> 
      <a href="#t2t39"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t37"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Bei unserem Layer wurden ja auch Funktionen zum Datenaustausch via UDP geschrieben. Au&szlig;erdem wurde hier auch einiges zu UDP erw&auml;hnt, so dass ich Ihnen hier ein kleines Client-/Server-Beispiel nicht vorenthalten will.</p>
<h4 class="t4">Der Server</h4>
<p><a id="Xxx999382" name="Xxx999382"></a><a id="Xxx999383" name="Xxx999383"></a>Der Server wartet auf die Verbindung irgendeines Clients, der einen einfachen String als zweites Argument in der Kommandozeile versendet. Der Server gibt diese Zeichen mitsamt der lokalen Server-Uhrzeit auf die Standardausgabe aus und wartet anschlie&szlig;end erneut wieder auf Daten am Port 1234 von irgendeinem Client.</p>
<pre>/* udp_server.c */
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include "socketprx.h"
#define LOCAL_SERVER_PORT 1234
#define BUF 255
int main (int argc, char **argv) {
  socket_t sock;
  char puffer[BUF];
  time_t time1;
  char loctime[BUF];
  char *ptr;
  /* Socket erzeugen */
  sock = create_socket( AF_INET, SOCK_DGRAM, 0);
  atexit(cleanup);
  bind_socket(&amp;sock, INADDR_ANY, LOCAL_SERVER_PORT);
  printf ("Warte auf Daten am Port (UDP) %u\n",
     LOCAL_SERVER_PORT);
  /* Server-Schleife */
  while (1) {
    memset (puffer, 0, BUF);
    UDP_recv( &amp;sock, puffer, BUF );
    /* Zeitangaben pr&auml;parieren */
    time(&amp;time1);
    strncpy(loctime, ctime(&amp;time1), BUF);
    ptr = strchr(loctime, '\n' );
    *ptr = '\0';
    /* Erhaltene Nachricht ausgeben */
    printf ("%s: Daten erhalten: %s\n",
            loctime, puffer);
  }
  return EXIT_SUCCESS;
}</pre>
<h4 class="t4">Der Client<a id="Xxx999386" name="Xxx999386"></a></h4>
<pre>/* udp_client.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
#define SERVER_PORT 1234
int main (int argc, char **argv) {
  socket_t sock;
  /* Kommandozeile auswerten */
  if (argc &lt; 3) {
    printf ("Usage: %s &lt;server&gt; &lt;string&gt;\n",argv[0]);
    exit (EXIT_FAILURE);
  }
  /* Socket erzeugen */
  sock = create_socket( AF_INET, SOCK_DGRAM, 0);
  atexit(cleanup);
  bind_socket(&amp;sock, INADDR_ANY, 0);
  UDP_send(&amp;sock,argv[2],strlen(argv[2]),argv[1], SERVER_PORT);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_11.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_11.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.10   
    </b>Der UDP-Server im Einsatz unter Linux</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_10.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_10.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.11   
    </b>Die (UDP)Client-Anwendung unter Linux</p>
<a name="t38"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t39"></a><h3 class="t3">28.7.8 Mehrere Clients gleichzeitig behandeln<a id="RxxobKap02800604002D221F0241BA" name="RxxobKap02800604002D221F0241BA"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t38"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999401" name="Xxx999401"></a>Einen gravierenden Nachteil allerdings hatten alle Server-Beispiele, die Sie bisher geschrieben haben. Alle Server sind nur f&uuml;r eine Client-Anfrage ausgelegt – sprich die Server konnten nur einen Client gleichzeitig bearbeiten. Alle anderen Clients wurden in die Warteschlange gesteckt und mussten warten, bis der Server wieder frei f&uuml;r weitere Verbindungsw&uuml;nsche ist. F&uuml;r Anwendungen wie Webserver, Chat-Programme, Spiele-Server etc. ist dieser Zustand unbrauchbar.</p>
<p>Um diesen Umstand zu verbessern, gibt es mehrere M&ouml;glichkeiten. Wobei sich hier die verschiedenen Varianten erheblich auf den Plattformen unterscheiden. Sinnvolle und m&ouml;gliche Varianten w&auml;ren:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Die Verwendung von (Multi-)Threads. Dabei wird f&uuml;r jeden Client ein neuer Thread gestartet. Der »Nachteil« von den Threads ist, dass es auf den verschiedenen Plattformen die verschiedensten Thread-Bibliotheken gibt und somit nur bedingt portabel sind.</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Die Verwendung von Prozessen. Hierbei wird f&uuml;r jeden Client ein neuer (Server-)Prozess gestartet – jeder Client bekommt hierbei praktisch seinen eigenen Server. Vorraussetzung hierf&uuml;r ist allerdings, dass Sie sich mit der Systemprogrammierung der entsprechenden Plattform auskennen. Schlie&szlig;lich m&uuml;ssen die einzelnen Prozesse kontrolliert werden.</td>
</tr>
</table>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Sofern Sie mehr zur Natur Linux/UNIX tendieren, kann ich Ihnen mein Buch <a href="http://www.galileocomputing.de/1137?GPP=opc" target="_blank">»Linux-UNIX-Programmierung«</a> ans Herz legen. Hier wird das Thema »Netzwerkprogrammierung« weit umfassender – auch mit den Threads und Prozessen – behandelt.</p>
</td>
</tr>
</table><br>
<p>Neben diesen M&ouml;glichkeiten gibt es selbstverst&auml;ndlich eine Reihe weiterer M&ouml;glichkeiten, um mehrere Clients zu behandeln. Unter MS-Windows bspw. k&ouml;nnten Sie hierf&uuml;r die <span class="listing">WSA</span>-Routinen <span class="listing">WSAAsyncSelect()</span> oder <span class="listing">WSAEventSelect()</span> verwenden. Bei Linux/UNIX hingegen w&uuml;rden sich hierbei auch asynchrone E/A-Routinen nach »POSIX«-Erweiterungen eignen.</p>
<h4 class="t4">select() – Eine portablere Altervative</h4>
<p><a id="Xxx999412" name="Xxx999412"></a><a id="Xxx999413" name="Xxx999413"></a>Neben den eben beschriebenen M&ouml;glichkeiten, die Sie verwenden k&ouml;nnen, um mehrere Clients zu behandeln, soll hier auf die M&ouml;glichkeit mit der Funktion <span class="listing">select()</span> etwas genauer eingegangen werden. Diese Funktion ist sowohl auf MS- als auch auf Linux/UNIX-Systemen vorhanden – und somit ein geeigneter Kandidat f&uuml;r eine portablere L&ouml;sung.</p>
<p>Das Problem bei einem Server, wie Sie ihn bisher verwendet haben, ist, dass dieser immer nur auf einen Socket-Deskriptor gewartet hat und auch immer &uuml;ber einen Socket-Deskriptor Daten empfangen bzw. versendet wurden. Wurde beim Server bspw. <span class="listing">revc()</span> aufgerufen, blockierte dieser Aufruf den Socket-Deskriptor solange, bis der Client wirklich Daten an diesen gesendet hat. Klar, man kann das Blockieren auch damit umgehen, indem man den Socket-Deskriptor als nicht-blockierend einrichtet (bspw. mit <span class="listing">fcntl()</span>). Allerdings sollte man bedenken, dass hierbei st&auml;ndig &uuml;berpr&uuml;ft wird, ob an einem Socket Daten vorliegen – das hei&szlig;t, es wird in einer Schleife dauerhaft gepollt – was die CPU unn&ouml;tig belastet. Mit der Funktion <span class="listing">select()</span> k&ouml;nnen Sie den Socket-Deskriptor so einrichten, dass nur dann CPU-Zeit ben&ouml;tigt wird, wenn auch wirklich Daten an einem Socket-Deskriptor vorliegen.</p>
<br><table width="100%" border="0" cellspacing="1" cellpadding="3">
<tr>
<td class="tabellentext" bgcolor="#000000">
<p class="BStandard"><b>Hinweis   </b>Dieser Abschnitt sollte nicht den Eindruck erwecken, die Funktion <span class="listing">select()</span> sei eine Routine, die sich nur zur Netzwerkprogrammierung eignet. <span class="listing">select()</span> kann &uuml;berall dort eingesetzt werden, wo auch Deskriptoren verwendet werden bzw. synchrones Multiplexing verwendet werden soll. Des Weiteren lassen sich mit <span class="listing">select()</span> auch hervorragend so genannte Timeouts einrichten. </p>
</td>
</tr>
</table><br>
<p>Hierzu die Syntax zur Funktion <span class="listing">select()</span> unter Linux/UNIX:</p>
<pre>// entsprechend nach POSIX 1003.1–2001
#include &lt;sys/select.h&gt;
// entsprechend nach fr&uuml;heren Standards
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
int select( int n, fd_set *readfds, fd_set *writefds,
            fd_set *exceptfds, struct timeval *timeout );</pre>
<p>Und hier die &auml;hnliche Syntax unter MS-Windows:</p>
<pre>int select( int n, fd_set FAR * readfds, fd_set FAR * writefds,
            fd_set FAR * exceptfds,
            const struct timeval FAR * timeout );</pre>
<p>Mit dem ersten Parameter <span class="listing">n</span> geben Sie die Gr&ouml;&szlig;e der folgenden Menge an. Hierf&uuml;r wird gew&ouml;hnlich der Wert des h&ouml;chsten (Socket-)Deskriptor plus eins angegeben. Sie sollten sich allerdings nicht darauf verlassen, dass hier automatisch eine aufsteigende und l&uuml;ckenlose Reihenfolge f&uuml;r die (Socket-)Deskriptoren vergeben werden. Welche Nummer der n&auml;chste (Socket-)Deskriptor verwendet, entscheidet immer noch das System. Daher empfiehlt es sich, jeden gesetzten (Socket-)Deskriptor mit dem zu vergleichen, welcher rein theoretisch der H&ouml;chste ist.</p>
<p>Die n&auml;chsten drei Parameter sind Zeiger auf die <span class="listing">fd_set</span>s, welche zum Lesen, Schreiben oder auf Ausnahmen getestet werden. Sofern Sie einen der Parameter nicht verwenden wollen, k&ouml;nnen Sie hierf&uuml;r <span class="listing">NULL</span> angeben. Drei getrennte Sets sind n&ouml;tig, da man ja nicht alle (Socket-)Deskriptoren auf Lesen oder Schreiben testen m&ouml;chte.</p>
<p>Der am h&auml;ufigsten verwendete Parameter (wie es auch im anschlie&szlig;enden Beispiel der Fall ist) ist <span class="listing">readfds</span>. Mit diesem Parameter wird &uuml;berpr&uuml;ft, ob auf den (Socket-)Deskriptoren Daten zum Lesen vorhanden sind. Das Gegenst&uuml;ck dazu ist der Parameter <span class="listing">writefds</span> – hiermit k&ouml;nnen Sie die Beschreibbarkeit von (Socket-)Deskriptoren &uuml;berpr&uuml;fen – sprich, ob ein Deskriptor bereit ist, eine Ausgabe anzunehmen (diese wird bspw. gerne bei Pipes verwendet). Der dritte <span class="listing">fd_set</span>-Parameter <span class="listing">exceptfds</span> wird weitaus seltener verwendet. Dieser kann verwendet werden, um zu &uuml;berpr&uuml;fen, ob bei einen (Socket-)Deskriptor irgendwelche besonderen Zust&auml;nde (Ausnahmen) vorliegen. Dies wird bspw. bei Out-of-band-Daten (<span class="listing">MSG_OOB</span>) verwendet (siehe Manual-Page zu <span class="listing">send()</span> und/oder <span class="listing">recv()</span>).</p>
<p>Nach dem Aufruf von <span class="listing">select()</span> wird diese Menge in Teilmengen der Filedeskriptoren verteilt, welche die Bedingungen erf&uuml;llen.</p>
<p>Mit dem letzten Parameter k&ouml;nnen Sie ein Timeout, eine Zeit im Format von Sekunden (<span class="listing">tv_sec</span>) und Mikrosekunden (<span class="listing">tv_usec</span>), einrichten. Diese Zeit wird dann abgewartet, bis eine bestimmte Bedingung eintritt. Sind Sie daran nicht interessiert, k&ouml;nnen Sie auch hier <span class="listing">NULL</span> angeben. Es gibt aber auch einen Nachteil, wenn sich <span class="listing">select()</span> vorzeitig verabschiedet (vor Ablauf der festgelegten Zeit). <span class="listing">select()</span> gibt keine Auskunft dar&uuml;ber, wie lange denn tats&auml;chlich gewartet wurde. Dazu muss extra eine Funktion wie bspw. <span class="listing">gettimeofday()</span> aufgerufen werden.</p>
<p>Die Funktion gibt die Anzahl der Filedeskriptoren zur&uuml;ck, die Ihre Bedingung erf&uuml;llt haben (einfach, die Anzahl der (Socket-)Deskriptoren, die bereit sind). Wenn die Zeit abgelaufen ist (Timeout) wird 0 und bei einem Fehler des Funktionsaufrufs <span class="listing">select()</span>-1 zur&uuml;ckgegeben.</p>
<p>Ein Problem bei <span class="listing">select()</span> ist, dass es mit Bitfeldern arbeitet – was somit abh&auml;ngig vom Betriebssystem ist. Die Bitfeldgr&ouml;&szlig;e bei BSD bspw. betr&auml;gt 256 und unter Linux 1024. Somit k&ouml;nnen auf BSD nur die ersten 256 und unter Linux 1024 Deskriptoren angesprochen werden. Unter MS-Windows kann dieser Wert gar nur bis zu 64 Deskriptoren betragen. Wie viele Deskriptoren Sie denn nun tats&auml;chlich pro Prozess verwenden k&ouml;nnen, ist mit der symbolischen Konstante <span class="listing">FD_SETSIZE</span> definiert. Nat&uuml;rlich macht es jetzt wenig Sinn, alle (Socket–) Deskriptoren zu &uuml;berwachen. Zum Gl&uuml;ck m&uuml;ssen Sie sich eigentlich recht wenig um diese Menge k&uuml;mmern, da Ihnen der Datentyp <span class="listing">fd_set</span> die Arbeit zum Speichern der (Socket-)Deskriptoren abnimmt und einige Makros den Zugriff darauf erleichtern. Hier die Makros, um die Mengen zu bearbeiten:<a id="Xxx999431" name="Xxx999431"></a><a id="Xxx999432" name="Xxx999432"></a><a id="Xxx999433" name="Xxx999433"></a><a id="Xxx999434" name="Xxx999434"></a><a id="Xxx999435" name="Xxx999435"></a><a id="Xxx999436" name="Xxx999436"></a><a id="Xxx999437" name="Xxx999437"></a><a id="Xxx999438" name="Xxx999438"></a></p>
<pre>FD_ZERO(fd_set *set);
FD_SET(int element, fd_set *set);
FD_CLR(int element, fd_set *set);
FD_ISSET(int element, fd_set *set);</pre>
<p>Die Makros lassen sich recht schnell erkl&auml;ren. <span class="listing">FD_ZERO()</span> macht aus der Menge <span class="listing">set</span> eine leere Menge, <span class="listing">FD_SET()</span> f&uuml;gt <span class="listing">element</span> der Menge <span class="listing">set</span> hinzu und <span class="listing">FD_CLR()</span> entfernt <span class="listing">element</span> aus der Menge <span class="listing">set</span>. Mit <span class="listing">FD_ISSET()</span> k&ouml;nnen Sie &uuml;berpr&uuml;fen, ob <span class="listing">element</span> in der Menge <span class="listing">set</span> vorkommt (genauer: gesetzt ist).</p>
<p>Das folgende Beispiel, ein einfacher TCP-Echo-Server, soll Ihnen die Funktion <span class="listing">select()</span> demonstrieren. Das Beispiel ist dem 1:1-Chat zwischen dem Server und dem Client recht &auml;hnlich, welches Sie in diesem Kapitel bereits geschrieben haben. Nur, begn&uuml;gen wir uns beim Server jetzt damit, dass dieser nur die Zeichenketten auf dem Bildschirm ausgibt und dem Client nicht antwortet. Allerdings mit dem gravierenden Unterschied, dass der Server nun mehrere Clients »gleichzeitig« behandeln kann. Genauer bis zu <span class="listing">FD_SETSIZE</span> Clients. Sobald auch hier ein Client die Zeichenfolge »quit« sendet, entfernt der Server den Client (genauer den (Socket-)Deskriptor) aus der Menge.</p>
<p>Im Beispiel wurde aus &Uuml;bersichtlichkeitsgr&uuml;nden darauf verzichtet, die <span class="listing">select()</span>-Abhandlung in unseren Layer SOCKETPRX zu implementieren. In der Praxis w&auml;re dies allerdings sehr sinnvoll, da die Verwendung von <span class="listing">select()</span> doch zu einem der etwas komplizierteren Teile der Programmierung geh&ouml;rt. Dank dem Layer SOCKETPRX, f&auml;llt allerdings die &Uuml;bersicht der Abhandlung von <span class="listing">select()</span> erheblich leichter als ohne. Hier der gut dokumentierte Source-Code zum Server, welcher nun mehrere Clients auf einmal abarbeiten kann:</p>
<pre>/* multi_server.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
int main (void) {
  socket_t sock1, sock2, sock3;
  int i, ready, sock_max, max=-1;
  int client_sock[FD_SETSIZE];
  fd_set gesamt_sock, lese_sock;
  char *buffer = (char*) malloc (BUF);
  sock_max = sock1 = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  bind_socket( &amp;sock1, INADDR_ANY, 15000 );
  listen_socket (&amp;sock1);
  for( i=0; i&lt;FD_SETSIZE; i++)
     client_sock[i] = –1;
  FD_ZERO(&amp;gesamt_sock);
  FD_SET(sock1, &amp;gesamt_sock);
  for (;;) {
    /* Immer Aktualisieren */
    lese_sock = gesamt_sock;
    /* Hier wird auf die Ankunft von Daten oder
     * neuer Verbindungen von Clients gewartet */
    ready = select( sock_max+1, &amp;lese_sock, NULL, NULL, NULL );
    /* Eine neue Client-Verbindung ... ? */
    if( FD_ISSET(sock1, &amp;lese_sock)) {
       accept_socket( &amp;sock1, &amp;sock2 );
       /* Freien Platz f&uuml;r (Socket-)Deskriptor
        * in client_sock suchen und vergeben */
       for( i=0; i&lt; FD_SETSIZE; i++)
          if(client_sock[i] &lt; 0) {
             client_sock[i] = sock2;
             break;
          }
       /* Mehr als FD_SETSIZE Clients sind nicht m&ouml;glich */
       if( i == FD_SETSIZE )
          error_exit("Server &uuml;berlastet – zuviele Clients");
       /* Den neuen (Socket-)Deskriptor zur
        * (Gesamt)Menge hinzuf&uuml;gen */
       FD_SET(sock2, &amp;gesamt_sock);
       /* select() ben&ouml;tigt die h&ouml;chste
        * (Socket-)Deskriptor-Nummer */
       if( sock2 &gt; sock_max )
          sock_max = sock2;
       /* h&ouml;chster Index f&uuml;r client_sock
        * f&uuml;r die anschlie&szlig;ende Schleife ben&ouml;tigt */
       if( i &gt; max )
          max = i;
       /* ... weitere (Lese-)Deskriptoren bereit ? */
       if( --ready &lt;= 0 )
          continue; //Nein ...
    } //if(FD_ISSET ...
    /* Ab hier werden alle Verbindungen von Clients auf
     * die Ankunft von neuen Daten &uuml;berpr&uuml;ft */
    for(i=0; i&lt;=max; i++) {
       if((sock3 = client_sock[i]) &lt; 0)
          continue;
       /* (Socket-)Deskriptor gesetzt ... */
       if(FD_ISSET(sock3, &amp;lese_sock)){
          /* ... dann die Daten lesen */
          TCP_recv (&amp;sock3, buffer, BUF-1);
          printf ("Nachricht empfangen: %s\n", buffer);
          /* Wenn quit erhalten wurde ... */
          if (strcmp (buffer, "quit\n") == 0) {
             /* ... hat sich der Client beendet */
             close_socket (&amp;sock3);        //Socket schlie&szlig;en
             FD_CLR(sock3, &amp;gesamt_sock);  //aus Menge l&ouml;schen
             client_sock[i] = –1;          //auf –1 setzen
             printf("Ein Client hat sich beendet\n");
          }
          /* Noch lesbare Deskriptoren vorhanden ... ? */
          if( --ready &lt;= 0 )
             break; //Nein ...
       }
    }
  } // for(;;)
  return EXIT_SUCCESS;
}</pre>
<p>Und jetzt noch der Quellcode zur entsprechenden Client-Anwendung:</p>
<pre>/* multi_client.c */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "socketprx.h"
#define BUF 1024
int main (int argc, char **argv) {
  socket_t sock;
  char *buffer = (char *)malloc (BUF);
  if( argc &lt; 2 ){
     printf("Usage: %s ServerAdresse\n", *argv);
     exit(EXIT_FAILURE);
  }
  sock = create_socket(AF_INET, SOCK_STREAM, 0);
  atexit(cleanup);
  connect_socket(&amp;sock, argv[1], 15000);
  do {
      buffer[0] = '\0';
      printf ("Nachricht zum Versenden: ");
      fgets (buffer, BUF, stdin);
      TCP_send (&amp;sock, buffer, strlen (buffer));
  } while (strcmp (buffer, "quit\n") != 0);
  close_socket (&amp;sock);
  return EXIT_SUCCESS;
}</pre>
<p>Das Programm bei der Ausf&uuml;hrung:</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_12.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_12.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.12   
    </b>Der Server kann jetzt mehrere Anfragen (Clients) bearbeiten</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_14.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_14.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.13   
    </b>Einer von zwei gerade aktiven Clients</p>
<p><a name="bild"></a><a href="#bild" onClick="OpenWin('bilder/28_13.gif','Abbildung',600,600)"><img border="0" src="bilderklein/klein28_13.gif" alt="Abbildung"><br><span class="tabunter">Hier klicken, um das Bild zu Vergr&ouml;&szlig;ern</span></a></p>
<p class="tabunter"><b>Abbildung 28.14   
    </b>Der andere der beiden aktiven Clients zur selben Zeit</p>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a class="navnav" href="c_028_005.htm"> &lt;&lt; zur&uuml;ck</a></td>
<td width="49%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="25%">
<div align="right"><a class="navnav" href="c_028_007.htm">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opc" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="http://www.galileocomputing.de/899?GPP=opc">
                                        <img src="common/643_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
                                        <br /><strong>C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="mailto:stefan.krumbiegel@galileo-press.de?subject=Meinung%20zu%20C%20von%20A%20bis%20Z%20(openbook)"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opc" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1007?GPP=opc">
                        <img src="common/683_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1137?GPP=opc">
                        <img src="common/749_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-UNIX-Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1004?GPP=opc">
                        <img src="common/644_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/880?GPP=opc">
                        <img src="common/573_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: UML 2.0" title="Zum Katalog: UML 2.0"><br /><br /><br /><br /><br /><br /><br />&nbsp;UML 2.0</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/967?GPP=opc">
                        <img src="common/626_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Reguläre Ausdrücke" title="Zum Katalog: Reguläre Ausdrücke"><br /><br /><br /><br /><br /><br /><br />&nbsp;Reguläre Ausdrücke</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/941?GPP=opc">
                        <img src="common/677_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux" title="Zum Katalog: Linux"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opc"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center"><br />
<div align="center">
<p class="standard"><b>Copyright © Galileo Press 2006</b><br>F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
