<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Galileo Computing :: C von A bis Z – 18.16 Zeilenweise Ein-/Ausgabe von Streams</title>
<meta name="title" content="Galileo Computing :: C von A bis Z">
<meta name="author" content="J&uuml;rgen Wolf">
<meta name="publisher" content="Galileo Press 2006">
<meta name="copyright" content="Galileo Press 2006">
<meta name="description" content="C von A bis Z - Das umfassende Handbuch f&uuml;r Linux, Unix und Windows – 2., aktualisierte und erweiterte Auflage 2006, geb., mit CD und Referenzkarte – ISBN 3-89842-643-2">
<meta name="audience" content="Alle">
<meta name="robots" content="INDEX,FOLLOW">
<meta http-equiv="content-language" content="de">
<link rel="stylesheet" type="text/css" href="common/galileo_open.css">
<link rel="prev" href="c_018_014.htm">
<link rel="next" href="c_018_016.htm"><script type="text/javascript" language="JavaScript"><!--
function OpenWin(url,name,height,width)
{
  var InfoWin = window.open(url,name,"directories=0,height="+height+",width=" + width + ",hotkeys=0,location=0,menubar=0,resizable=1,screenX=150,screenY=10,left=150,top=10,scrollbars=1,status=1,titlebar=0,toolbar=0");
  InfoWin.focus();
}
//--></script></head>
<body vlink="#000099" link="#000099" alink="#000099">
    <table width="100%" height="74" border="0" cellpadding="0" cellspacing="0" bgcolor="#000066">
        <tr>
            <td height="74" valign="bottom" colspan="2"><a href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc"><img src="common/galileocomputing_openbook.gif" width="200" height="56" border="0" alt="Galileo Computing < openbook >" title="Galileo Computing < openbook >"></a></td>
            <td width="80" height="74"><a href="http://www.galileocomputing.de/?GPP=opc"><img src="common/galileocomputing.gif" border="0" alt="Galileo Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger." title="Galileo Computing - Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger."></a></td>
        </tr>
    </table>
    <div align="right"><a href="http://www.galileocomputing.de/?GPP=opc" class="navnav">Professionelle B&uuml;cher. Auch f&uuml;r Einsteiger.</a></div>
    <br />
<table border="0" cellpadding="0" cellspacing="0" width="100%">
    <tr>
        <td width="156" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="100%" align="left">
        <tr>
            <td colspan="2" class="nav1" align="left" valign="top" height="150">
                <table class="tbl1" width="150" border="0" cellpadding="3" cellspacing="0">
<tr>
<td class="tbl2" height="25"><a class="nav" href="./index.htm">Inhaltsverzeichnis</a></td>
</tr>
<tr>
<td><a class="navnav" href="./c_000Vorwort_000.htm#Xxx999266">Vorwort</a></td>
</tr>
<tr>
<td><a class="navnav" href="./c_000VorwortGutachter_000.htm#Xxx999275">Vorwort des Gutachters</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_001_000.htm#Xxx999328">1 Einstieg in C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_002_000.htm#Xxx999328">2 Das erste Programm</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_003_000.htm#Xxx999328">3 Zeichens&auml;tze</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_004_000.htm#Xxx999329">4 Kommentare in C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_005_000.htm#Xxx999330">5 Formatierte Eingabe mit scanf()</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_006_000.htm#Xxx999330">6 Formatierte Ausgabe mit printf</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_007_000.htm#Xxx999329">7 Elementare Datentypen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_008_000.htm#Xxx999328">8 Operatoren</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_009_000.htm#Xxx999328">9 Typenumwandlung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_010_000.htm#Xxx999328">10 Kontrollstrukturen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_011_000.htm#Xxx999328">11 Funktionen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_012_000.htm#Xxx999328">12 Pr&auml;prozessor-Direktiven</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_013_000.htm#Xxx999328">13 Arrays</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_014_000.htm#Xxx999328">14 Zeiger (Pointer)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_015_000.htm#Xxx999328">15 Kommandozeilenargumente</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_016_000.htm#Xxx999328">16 Dynamische Speicherverwaltung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_017_000.htm#Xxx999328">17 Strukturen</A></td>
</tr>
<tr>
<td><A class="navh" href="./c_018_000.htm#Xxx999328">18 Ein-/Ausgabe-Funktionen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_019_000.htm#Xxx999328">19 Attribute von Dateien und Arbeiten mit Verzeichnissen (nicht ANSI C)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_020_000.htm#Xxx999328">20 Arbeiten mit variablen langen Argumentlisten – &lt;stdarg.h&gt;</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_021_000.htm#Xxx999328">21 Zeitroutinen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_022_000.htm#Xxx999328">22 Weitere Headerdateien und ihre Funktionen (ANSI C)</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_023_000.htm#Xxx999328">23 Dynamische Datenstrukturen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_024_000.htm#Xxx999328">24 Algorithmen</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_025_000.htm#Xxx999328">25 Sicheres Programmieren</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_026_000.htm#Xxx999328">26 CGI mit C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_027_000.htm#Xxx999328">27 MySQL und C</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_028_000.htm#Xxx999328">28 Netzwerkprogrammierung und Cross-Plattform-Entwicklung</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_029_000.htm#Xxx999328">29 Wie geht’s jetzt weiter?</A></td>
</tr>
<tr>
<td><a class="navnav" href="./c_030Anhang_000.htm#Xxx999266">A Anhang</A></td>
</tr>
<tr>
<td><a class="navnav" href="./stichwort.htm#Xxx512322">Index</a></td>
</tr>
<tr><td><br /><a class="navnav" href="http://download.galileo-press.de/openbook/c_von_a_bis_z/galileocomputing_c_von_a_bis_z.zip"><strong>Download:</strong><br />- ZIP, ca. 8,5 MB</a></td></tr>
<tr><td><a class="navnav" href="http://www.galileocomputing.de/899?GPP=opc">Buch bestellen</a></td></tr>
<tr><td><a class="navnav" href="mailto:stefan.krumbiegel@galileo-press.de?subject=Meinung%20zu%20C%20von%20A%20bis%20Z%20(openbook)">Ihre Meinung?</a><br /><br /></td></tr>
</table></td>
</tr>
</table>
</td>
<td width="10"><img src="common/spacer10.gif" width="10" height="10"></td>
<td width="85%" valign="top" align="center">
    <div align="center">
        <table width="98%" border="0" cellspacing="0" cellpadding="0" bgcolor="#FFFFFF">
            <tr>
                <td width="100%" class="start" colspan="1" height="22" align="center">
                    <table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a class="navnav" href="c_018_014.htm"> &lt;&lt; zur&uuml;ck</a></td>
<td width="49%">
<div align="center"><a href="http://www.galileocomputing.de/?GPP=opc" class="navnav">Galileo Computing /</a><a class="navnav" href="http://www.galileocomputing.de/katalog/openbook/?GPP=opc"> &lt;openbook&gt; /</a><a href="./index.htm" class="navnav"> C von A bis Z</a></div>
</td>
<td align="right" width="25%">
<div align="right"><a class="navnav" href="c_018_016.htm">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" valign="top">
    <table width="100%" border="0" cellpadding="10" cellspacing="0" class="box">
        <tr>
            <td colspan="2"><a href="http://www.galileocomputing.de/899?GPP=opc" class="buchtitel">C von A bis Z</a><span class="autor"> von J&uuml;rgen Wolf</span><br><span class="untertitel">Das umfassende Handbuch f&uuml;r Linux, Unix und Windows <br />– 2., aktualisierte und erweiterte Auflage 2006</span></td>
        </tr>
        <tr>
            <td valign="top" width="90"><a href="http://www.galileocomputing.de/899?GPP=opc"><img src="common/643.gif" border="0" alt="Buch: C von A bis Z" title="Buch: C von A bis Z" align="left"><br /><br /><span class="autor"><strong>C von A bis Z</strong><br />1.116 S., mit CD, Referenzkarte, 39,90 Euro<br />Galileo Computing<br />ISBN 3-89842-643-2</span></a></a></td>
            <td width="80%">
<table border="0">
<tr>
<td valign="baseline"><img src="common/pfeil_u.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="3" class="kap"><b>Kapitel <a href="./c_018_000.htm#RxxobKap018000040029FC1F01818C">18 Ein-/Ausgabe-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_000.htm#RxxobKap018000040029FC1F01818E">18.1 Was ist eine Datei?</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_001.htm#RxxobKap01800104002A171F03418C">18.2 Formatierte und unformatierte Ein-/Ausgabe</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_002.htm#RxxobKap01800204002A181F01A18C">18.3 Streams</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_003.htm#RxxobKap01800304002A191F02918C">18.4 H&ouml;here Ein-/Ausgabe-Funktionen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_004.htm#RxxobKap01800404002A1A1F03618C">18.5 Datei (Stream) &ouml;ffnen – fopen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_004.htm#RxxobKap01800404002A1A1F0361B5">18.5.1 Modus f&uuml;r fopen()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_004.htm#RxxobKap01800404002A1A1F036208">18.5.2 Maximale Anzahl ge&ouml;ffneter Dateien – FOPEN_MAX</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_005.htm#RxxobKap01800504002A1B1F03018C">18.6 Zeichenweise Lesen und Schreiben – getchar und putchar</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_005.htm#RxxobKap01800504002A1B1F03019C">18.6.1 Ein etwas portableres getch()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_006.htm#RxxobKap01800604002A1C1F02A18C">18.7 Zeichenweise Lesen und Schreiben – putc/fputc und getc/fgetc</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_007.htm#RxxobKap01800704002A1D1F04718C">18.8 Datei (Stream) schlie&szlig;en – fclose</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_008.htm#RxxobKap01800804002A1E1F03E18C">18.9 Formatiertes Einlesen/Ausgeben von Streams mit fprintf und fscanf</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_009.htm#RxxobKap01800904002A1F1F04D18C">18.10 Standard-Streams in C</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_009.htm#RxxobKap01800904002A1F1F04D198">18.10.1 Standard-Streams umleiten</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_010.htm#RxxobKap01801004002A201F03A18C">18.11 Fehlerbehandlung von Streams – feof, ferror und clearerr</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_011.htm#RxxobKap01801104002A211F04518C">18.12 Gelesenes Zeichen in die Eingabe zur&uuml;ck-schieben – ungetc</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_012.htm#RxxobKap01801204002A221F02B18C">18.13 (Tastatur-)Puffer leeren – fflush</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_012.htm#RxxobKap01801204002A221F02B194">18.13.1 Pufferung</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_013.htm#RxxobKap01801304002A231F01418C">18.14 Stream positionieren – fseek, rewind und ftell</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_014.htm#RxxobKap01801404002A241F01D18C">18.15 Stream positionieren – fsetpos, fgetpos</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a class="navh" href="#RxxobKap01801504002A251F04018C">18.16 Zeilenweise Ein-/Ausgabe von Streams</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap01801504002A251F04018D">18.16.1 Zeilenweise Lesen mit gets/fgets</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap01801504002A251F04019E">18.16.2 Zeilenweise Schreiben mit puts/fputs</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap01801504002A251F0401A4">18.16.3 Zeilenweise Einlesen vom Stream mit getline() (nicht ANSI C)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a class="navh" href="#RxxobKap01801504002A251F0401B0">18.16.4 Rezepte f&uuml;r zeilenweises Einlesen und Ausgeben</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_016.htm#RxxobKap01801604002A261F02518C">18.17 Blockweise Lesen und Schreiben – fread und fwrite</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_016.htm#RxxobKap01801604002A261F025194">18.17.1 Blockweises Lesen – fread()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_016.htm#RxxobKap01801604002A261F0251A0">18.17.2 Blockweises Schreiben – fwrite()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_016.htm#RxxobKap01801604002A261F0251BD">18.17.3 Big-Endian und Little-Endian</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_017.htm#RxxobKap01801704002A271F01B18C">18.18 Datei (Stream) erneut &ouml;ffnen – freopen</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_018.htm#RxxobKap01801804002A281F03718C">18.19 Datei l&ouml;schen oder umbenennen – remove und rename</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_018.htm#RxxobKap01801804002A281F03718E">18.19.1 remove()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_018.htm#RxxobKap01801804002A281F037198">18.19.2 rename()</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_019.htm#RxxobKap01801904002A291F02118C">18.20 Pufferung einstellen – setbuf und setvbuf</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_020.htm#RxxobKap01802004002A2A1F02818C">18.21 Tempor&auml;re Dateien erzeugen – tmpfile und tmpnam</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline"><b><a href="./c_018_020.htm#RxxobKap01802004002A2A1F0281A5">18.21.1 mkstemp() – Sichere Alternative f&uuml;r Linux/UNIX (nicht ANSI C)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_021.htm#RxxobKap01802104002A2B1F03018C">18.22 Fehlerausgabe mit strerror und perror</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_022.htm#RxxobKap01802204002A2C1F01018C">18.23 Formatiert in einem String schreiben und formatiert aus einem String lesen – sscanf und sprintf</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_023.htm#RxxobKap01802304002A2D1F03E18C">18.24 Fortgeschrittenes Thema</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_024.htm#RxxobKap01802404002A2E1F04818C">18.25 Low-Level-Datei-I/O-Funktionen (nicht ANSI C)</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_025.htm#RxxobKap01802504002A2F1F02418C">18.26 Datei &ouml;ffnen – open</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_026.htm#RxxobKap01802604002A301F03118C">18.27 Datei schlie&szlig;en – close</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_027.htm#RxxobKap01802704002A311F03718C">18.28 Datei erzeugen – creat</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_028.htm#RxxobKap01802804002A321F02F18C">18.29 Schreiben und Lesen – write und read</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_029.htm#RxxobKap01802904002A331F01E18C">18.30 File-Deskriptor positionieren – lseek</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_030.htm#RxxobKap01803004002A341F01C18C">18.31 File-Deskriptor von einem Stream – fileno</a></b></td>
</tr>
<tr>
<td valign="baseline" width="10"> </td>
<td valign="baseline" width="10"><img src="common/pfeil_rechts5.gif" width="10" height="10" border="0" alt="gp"></td>
<td valign="baseline" colspan="2"><b><a href="./c_018_031.htm#RxxobKap01803104002A351F03718C">18.32 Stream von File-Deskriptor – fdopen</a></b></td>
</tr>
</table><br></td>
</tr>
</table>
<table width="100%" cellpadding="20" cellspacing="0" border="0" bgcolor="#eeeeee">
<tr>
<td>
<a name="t21"></a><a name="t2t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div>
<h2 class="t2">18.16 Zeilenweise Ein-/Ausgabe von Streams<a id="RxxobKap01801504002A251F04018C" name="RxxobKap01801504002A251F04018C"></a> 
      <a href="#t2t32"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"></h2>
<a name="t31"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t32"></a><h3 class="t3">18.16.1 Zeilenweise Lese<a id="Xxx999329" name="Xxx999329"></a>n mit gets/fget<a id="RxxobKap01801504002A251F04018D" name="RxxobKap01801504002A251F04018D"></a>s 
      <a href="#t2t33"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t31"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999331" name="Xxx999331"></a>Nun folgen Funktionen zum zeilenweisen Lesen und Schreiben von einem oder in einen Stream. Zuerst die Funktionen zum Lesen:<a id="Xxx999333" name="Xxx999333"></a><a id="Xxx999334" name="Xxx999334"></a></p>
<pre>#include &lt;stdio.h&gt;
char *gets(char *puffer);
char *fgets(char *puffer, int n, FILE *datei);</pre>
<p>Mit <span class="listing">fgets()</span> wird zeilenweise vom Stream <span class="listing">datei</span> bis zum n&auml;chsten Newline-Zeichen gelesen. Die gelesene Zeile befindet sich in der Adresse von <span class="listing">puffer</span> mit dem Newline-Zeichen <span class="listing">'\n'</span> und dem abschlie&szlig;enden <span class="listing">'\0'</span>-Zeichen. Mit <span class="listing">gets()</span> k&ouml;nnen Sie ebenso zeilenweise einlesen, allerdings nur von der Standardeingabe (<span class="listing">stdin</span>). Beispielsweise:</p>
<pre>/* gets.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(void) {
   char name[20];
   printf("Bitte geben Sie Ihren Namen ein : ");
   gets(name);  /* Gef&auml;hrlich */
   printf("Hallo %s\n",name);
   return EXIT_SUCCESS;
}</pre>
<p>Auf Linux/UNIX wird der Compiler bei diesem Programm vern&uuml;nftigerweise eine Warnung ausgeben. Die Warnung, diese Funktion nicht zu verwenden, ist in Ordnung, aber vielleicht sollten gerade f&uuml;r Anf&auml;nger auch noch der Grund und die Alternativen bei der Fehlermeldung mit angegeben werden.</p>
<p>Da die Funktion <span class="listing">gets()</span> nicht die Anzahl der einzugebenden Zeichen &uuml;berpr&uuml;ft, kann dies zu einem Puffer&uuml;berlauf (Buffer Overflow<a id="Xxx999340" name="Xxx999340"></a>) f&uuml;hren. Deshalb sollten Sie auf keinen Fall <span class="listing">gets()</span>, sondern die Funktion <span class="listing">fgets()</span> verwenden.</p>
<p>Wenn Sie die Syntax von <span class="listing">fgets()</span> betrachten, bemerken Sie, dass sich darin au&szlig;er der Zieladresse, in der die Daten eingelesen werden, zus&auml;tzlich ein Stream (<span class="listing">FILE</span> Zeiger) und ein Integer-Wert befinden, der die Anzahl der einzulesenden Zeichen festlegt. Mit <span class="listing">fgets</span> werden somit <span class="listing">n</span> Zeichen oder bis zum n&auml;chsten Newline (<span class="listing">'\n'</span>) aus dem Stream in die Adresse von <span class="listing">puffer</span> gelesen. Wobei der Stream eine beliebig ge&ouml;ffnete Datei oder auch die Standardeingabe (<span class="listing">stdin</span>) sein kann. Hierzu das vorige Beispiel mit <span class="listing">fgets()</span>:</p>
<pre>/* fgets1.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 20
int main(void) {
   char name[MAX];
   printf("Bitte geben Sie Ihren Namen ein : ");
   fgets(name, MAX, stdin);
   printf("Hallo %s",name);
   return EXIT_SUCCESS;
}</pre>
<p>Sollten hier mehr als 20 Zeichen eingegeben werden, l&auml;uft das Programm trotzdem f&uuml;r immer anstandslos. Es werden 20 Zeichen bzw. 18 darstellbare Zeichen + <span class="listing">'\n'</span> + <span class="listing">'\0'</span> an den String <span class="listing">name</span> &uuml;bergeben. Ein Vorteil ist, dass mit <span class="listing">fgets()</span> nicht nur von <span class="listing">stdin</span> gelesen werden kann, sondern auch von einem beliebigen Stream. Hier ein Beispiel, wie Sie mit <span class="listing">fgets()</span> zeilenweise aus einer Datei lesen k&ouml;nnen:</p>
<pre>/* fgets2.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ZEILENLAENGE 80
int main(void) {
   FILE *quelle;
   char puffer[ZEILENLAENGE], name[20];
   printf("Welche Datei wollen Sie zum Lesen &ouml;ffnen: ");
   scanf("%s",name);
   if( (quelle=fopen(name,"r")) == NULL) {
      fprintf(stderr, "Kann %s nicht oeffnen\n", name);
      return EXIT_FAILURE;
   }
   while(fgets(puffer, ZEILENLAENGE, quelle))
      fputs(puffer, stdout);
   return EXIT_SUCCESS;
}</pre>
<p><a id="Xxx999345" name="Xxx999345"></a>Weil beim Einlesen vom Stream der Standardeingabe (<span class="listing">stdin</span>) mit <span class="listing">fgets()</span> auch das <span class="listing">'\n'</span>-Zeichen mit eingelesen wird, verwenden einige Programmierer, sei es aus Faulheit oder mangelndem Wissen, die Funktion <span class="listing">gets()</span>, obwohl sie wissen, dass sie diese Funktion nicht verwenden sollten. H&auml;ufig haben diese Programmierer Probleme mit dem Newline-Zeichen am Ende von Stringvergleichen, wie das folgende Beispiel zeigt:</p>
<pre>/* fgets3.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define PASSWORT "Schiller"
#define MAX 10
int main(void) {
   char pswd[MAX];
   printf("Passwort: ");
   fgets(pswd, MAX, stdin);
   if(strcmp(PASSWORT, pswd) == 0)
      printf("Willkommen\n");
   else
      printf("Passwort falsch\n");
   return EXIT_SUCCESS;
}</pre>
<p>Auch wenn hier der Benutzer das richtige Passwort eingibt, schl&auml;gt der Stringvergleich fehl, weil <span class="listing">fgets()</span> das Newline-Zeichen mit einliest. Dieses Problem l&auml;sst sich mit ein paar Zeilen Code beheben:</p>
<pre>/* fgets4.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define PASSWORT "Schiller"
#define MAX 10
void chomp(char *str) {
   size_t p=strlen(str);
   /* '\n' mit '\0' &uuml;berschreiben */
   str[p-1]='\0';
}
int main(void) {
   char pswd[MAX];
   printf("Passwort: ");
   fgets(pswd, MAX, stdin);
   /* ... letztes Zeichen vor \0 entfernen */
   chomp(pswd);
   if(strcmp(PASSWORT, pswd) == 0)
      printf("Willkommen\n");
   else
      printf("Passwort falsch\n");
   return EXIT_SUCCESS;
}</pre>
<p>Die Funktion <span class="listing">chomp()</span> nimmt nichts anderes vor, als das letzte Zeichen vor dem Terminierungszeichen <span class="listing">'\0'</span> zu entfernen. Dabei wird die Anzahl der Zeichen mit der Funktion <span class="listing">strlen()</span> gez&auml;hlt. Zieht man von diesem Wert eins ab und verwendet ihn als Indexz&auml;hler mit dem Indizierungsoperator, befinden Sie sich ein Zeichen vor <span class="listing">'\0'</span>.</p>
<a name="t32"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t33"></a><h3 class="t3">18.16.2 Zeilenweise Schreibe<a id="Xxx999352" name="Xxx999352"></a>n mit puts/fput<a id="RxxobKap01801504002A251F04019E" name="RxxobKap01801504002A251F04019E"></a>s 
      <a href="#t2t34"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t32"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p><a id="Xxx999354" name="Xxx999354"></a>Mit <span class="listing">puts()</span> wird eine ganze Zeile auf dem Bildschirm (<span class="listing">stdout</span>) ausgegeben. Au&szlig;erdem gibt <span class="listing">puts()</span> am Ende der Zeichenkette noch ein <span class="listing">'\n'</span>-Zeichen mit aus, die Funktion <span class="listing">fputs()</span> macht dies hingegen nicht. Im Gegensatz zu <span class="listing">puts()</span>, womit Sie nur auf die Standardausgabe (<span class="listing">stdout</span>) schreiben k&ouml;nnen, verwendet <span class="listing">fputs()</span>, wie schon <span class="listing">fgets()</span>, einen beliebig offenen Stream, in den geschrieben wird. Als Stream ist eine Datei zul&auml;ssig, die mit einem Schreibmodus ge&ouml;ffnet wurde, oder auch die Standardausgabe (<span class="listing">stdout</span>). Hier die Syntax der beiden Funktionen:<a id="Xxx999356" name="Xxx999356"></a><a id="Xxx999357" name="Xxx999357"></a></p>
<pre>#include &lt;stdio.h&gt;
int puts(const char *puffer);
int fputs(const char *puffer, FILE *datei);</pre>
<p>Auch hierzu ein kleines Beispiel:</p>
<pre>/* fputs.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ZEILENLAENGE 80
int main(void) {
   FILE *quelle, *kopie;
   char puffer[ZEILENLAENGE], name[20];
   printf("Welche Datei wollen Sie zum Lesen &ouml;ffnen: ");
   scanf("%s",name);
   if( (quelle=fopen(name,"r")) == NULL) {
      fprintf(stderr,"Kann %s nicht oeffnen\n",name);
      return EXIT_FAILURE;
   }
   if( (kopie=fopen("kopie.txt","w")) == NULL) {
      fprintf(stderr,"Kann kopie.txt nicht oeffnen\n");
      return EXIT_FAILURE;
   }
   while(fgets(puffer,ZEILENLAENGE,quelle)) {
      fputs(puffer, kopie);
      puts(puffer);
   }
   return EXIT_SUCCESS;
}</pre>
<p><span class="listing">fputs()</span> wird hier eingesetzt, um den Puffer, der mit <span class="listing">fgets()</span> ausgelesen wurde, in eine Datei namens »kopie.txt« zu schreiben. <span class="listing">puts()</span> hingegen gibt alles auf dem Bildschirm aus. Somit wird eine Zeile in die Datei »kopie.txt« geschrieben und dasselbe gleich nochmals auf dem Bildschirm ausgegeben.</p>
<a name="t33"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t34"></a><h3 class="t3">18.16.3 Zeilenweise Einlesen vom Stream mit getline() 
(nicht ANSI C<a id="RxxobKap01801504002A251F0401A4" name="RxxobKap01801504002A251F0401A4"></a>) 
      <a href="#t2t35"><img src="common/down.gif" width="15" height="15" border="0" alt="down"></a><a href="#t2t33"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Den Benutzern des GNU-gcc Compilers sei noch die Funktion <span class="listing">getline()</span> ans Herz gelegt. Sie geh&ouml;rt zwar nicht zum Umfang von ANSI C, jedoch wird in dem »The GNU C Library Reference Manual« unter <a href="http://www.gnu.org" target="_blank">www.gnu.org</a> explizit darauf verwiesen. Warum diese Funktion so besonders ist, wird im Anschluss erl&auml;utert.</p>
<p>Die Funktion <span class="listing">getline()</span> kann als Ersatz f&uuml;r die E/A-Funktion <span class="listing">fgets()</span> verwendet werden oder noch allgemeiner – f&uuml;r das Einlesen einer Zeile von einem Stream. Zun&auml;chst aber die Syntax der Funktion, welche in <span class="listing">&lt;stdio.h&gt;</span> deklariert ist:</p>
<pre>ssize_t getline (char **lineptr, size_t *n, FILE *stream)</pre>
<p>Die Funktion liest eine Zeile inklusive dem Newline (<span class="listing">'\n'</span>) und dem Stringende-Zeichen (<span class="listing">'\0'</span>) in einen Puffer ein und speichert die Adresse des Puffers in <span class="listing">*lineptr</span>.</p>
<p>Bevor Sie <span class="listing">getline()</span> aufrufen, sollten Sie in <span class="listing">*lineptr</span> die Adresse eines zuvor mit <span class="listing">malloc()</span> allokierten Puffers der L&auml;nge <span class="listing">*n</span> Bytes bereitstellen.</p>
<p>Jetzt aber der eigentliche Clou an der Sache: Ist der &uuml;bergebene Puffer gro&szlig; genug, erhalten Sie in etwa den Zustand, den Sie auch mit der Funktion <span class="listing">fgets()</span> erreichen k&ouml;nnen. Ist dies aber nicht der Fall, verh&auml;lt sich <span class="listing">getline()</span> nicht wie <span class="listing">fgets()</span> und h&ouml;rt bei &Uuml;berschreitung der angegebenen Puffergr&ouml;&szlig;e einfach auf, die Zeile einzulesen. Vielmehr wird der Puffer innerhalb der Funktion auf die erforderliche Gr&ouml;&szlig;e mit <span class="listing">realloc()</span> angepasst. Wenn Sie sich dieses Szenario nun noch mit der Funktion <span class="listing">gets()</span> vorstellen, ist das eigenst&auml;ndige K&uuml;rzen der einzulesenden Zeile, wie es bei <span class="listing">fgets()</span> geschehen w&uuml;rde, noch das geringere &Uuml;bel.</p>
<p>Das war aber noch nicht alles. Wird <span class="listing">*lineptr</span> vor dem Aufruf mit einem <span class="listing">NULL</span>-Zeiger initialisiert und <span class="listing">*n</span> auf 0 gesetzt, &uuml;bernimmt <span class="listing">getline()</span> die Bereitstellung des Speichers f&uuml;r die Zeile vollkommen selbstst&auml;ndig, und Sie m&uuml;ssen sich um nichts weiter k&uuml;mmern.</p>
<p>Die Funktion gibt die Anzahl der eingelesenen Zeichen inklusive des Zeilen-Trennzeichens (<span class="listing">'\n'</span>), aber ohne das abschlie&szlig;ende Terminierungszeichen (<span class="listing">'\0'</span>) zur&uuml;ck – bei einem Fehler oder bei <span class="listing">EOF</span> erhalten Sie von <span class="listing">getline()</span> –1.</p>
<p>Wenn Sie <span class="listing">getline()</span> verwenden wollen, m&uuml;ssen Sie die Konstante <span class="listing">_GNU_SOURCE</span> vor allen <span class="listing">include</span>-Anweisungen definieren. Laut der GNU-Dokumentation ist diese Funktion der empfohlene Weg, Zeilen vom Stream zu lesen. Sie gilt als die sicherste ihrer Art. In diesem Zusammenhang sei aber nochmals auf das »The GNU C Library Reference Manual« verwiesen.</p>
<p>Hier ein einfaches Beispiel f&uuml;r den Fall, dass Sie die Bereitstellung des Puffers vollst&auml;ndig <span class="listing">getline()</span> &uuml;berlassen wollen:</p>
<pre>/* getline.c */
#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stddef.h&gt;
int main(void) {
   FILE *fd;
   /* Bitte die Datei und event. den Pfad anpassen */
   char *datei = "/home/user/testdatei.txt";
   int nRet;
   size_t *t = malloc(0);
   char **gptr = (char **)malloc(sizeof(char*));
   *gptr = NULL;
   if ( (fd = fopen(datei,"r")) == NULL) {
      fprintf(stderr, "\nKonnte Datei %s nicht &ouml;ffnen!", datei);
      return EXIT_FAILURE;
   }
   while( (nRet=getline(gptr, t, fd)) &gt; 0)
      fputs(*gptr,stdout);
  return EXIT_SUCCESS;
}</pre>
<a name="t34"></a><br><div align="center"><a href="#top"><img src="common/jupiters.gif" border="0" alt="Galileo Computing - Zum Seitenanfang" title="Galileo Computing - Zum Seitenanfang"></a></div><a name="t2t35"></a><h3 class="t3">18.16.4 Rezepte f&uuml;r zeilenweises Einlesen und Ausgeben<a id="RxxobKap01801504002A251F0401B0" name="RxxobKap01801504002A251F0401B0"></a> 
      <img src="common/15x15leer.gif" width="15" height="15" border="0" alt="top"><a href="#t2t34"><img src="common/top.gif" width="15" height="15" border="0" alt="top"></a></h3>
<p>Es folgen jetzt einige n&uuml;tzliche Listings, die h&auml;ufig zum zeilenweisen Einlesen und Ausgeben ben&ouml;tigt werden. Beispiele, die auf Probleme wie die folgenden abheben:</p>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich die <span class="listing">n</span>-te Zeile auslesen?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich von Zeile <span class="listing">n1</span> bis <span class="listing">n2</span> lesen?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich alle Zeilen ausgeben, die eine bestimmte Stringfolge enthalten?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Wie kann ich alle Zeilen ausgeben, die ein bestimmtes Wort enthalten?</td>
</tr>
</table>
<table width="100%" border="0">
<tr>
<td valign="baseline" width="16"><img src="common/gp.gif" width="8" height="9" border="0" alt="gp"> 
        </td>
<td valign="top" width="100%" align="left"> Suchen und Ersetzen in einer Textdatei (nur ganze Worte, keine Teilstrings)</td>
</tr>
</table>
<h4 class="t4">Wie kann ich die n-te Zeile auslesen<a id="Xxx999381" name="Xxx999381"></a>?</h4>
<pre>/* read_nline.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define BUF 255
char temp[BUF];
char puffer[BUF];
/* Auslesen der n-ten Zeile */
char *getsline_number(int n, FILE *file) {
   int i;
   for(i = 0; i &lt; n-1; i++)
      if(fgets(temp, BUF, file) == NULL)
         /* Bis zur n-ten Zeile lesen */
         return NULL; /* Zeile scheint nicht zu existieren */
   /* Stream ist jetzt in der n-ten Zeile */
   if(fgets(puffer,BUF,file) == NULL)
      return NULL; /* Zeile scheint nicht zu existieren */
   return puffer; /* Zeile an Aufrufer zur&uuml;ck */
}
int main(int argc, char **argv) {
   FILE *f;
   unsigned int line;
   char *linenr;
   if(argc &lt; 2) {
      fprintf(stderr, "Verwendung : %s datei\n",*argv);
      return EXIT_FAILURE;
   }
   f = fopen(argv[1],"r");
   if(f == NULL) {
      printf("Fehler beim &Ouml;ffnen");
      return EXIT_FAILURE;
   }
   printf("Welche Zeile wollen Sie lesen : ");
   scanf("%d",&amp;line);
   linenr=getsline_number(line, f);
   if(linenr == NULL) {
      fprintf(stderr, "Fehler beim Lesen der"
                      " %d-ten Zeile??\n",line);
      return EXIT_FAILURE;
    }
   printf("Zeile %d : %s\n", line, linenr);
   return EXIT_SUCCESS;
}</pre>
<h4 class="t4">Wie kann ich von Zeile n1 bis n2 lesen<a id="Xxx999384" name="Xxx999384"></a>?</h4>
<pre>/* read_line_n2n.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define BUF 255
char temp[BUF];
char puffer[BUF];
int i;  /* Zeilenzaehler */
/* Lesen von Zeile n1 bis Zeile n2 */
char *getsline_number(int n1,int n2, FILE *file) {
   for(i = 0; i &lt; n1–1; i++)
      /* Bis zur n1-ten Zeile lesen */
      if(fgets(temp, BUF, file) == NULL)
         return NULL; /* Zeile scheint nicht zu existieren */
   /* Jetzt beginnt das eigentliche Lesen */
   printf("\n\n");
   for(i = n1; i &lt;= n2; i++) {
      if(fgets(puffer,BUF,file) == NULL)
         /* Stream ist jetzt in der n-ten Zeile */
         return NULL;  /* Zeile scheint nicht zu existieren */
      printf("Zeile %d : %s", i, puffer);
   }
}
int main(int argc, char **argv) {
   FILE *f;
   int line1, line2;
   char *linenr;
   if(argc &lt; 2) {
      fprintf(stderr, "Verwendung : %s datei\n", *argv);
      return EXIT_FAILURE;
   }
   f = fopen(argv[1],"r");
   if(f == NULL) {
      printf("Fehler bei fopen()...\n");
      return EXIT_FAILURE;
   }
   printf("von Zeile wollen Sie lesen : ");
   scanf("%d", &amp;line1);
   printf("bis Zeile wollen Sie lesen : ");
   scanf("%d", &amp;line2);
   if(line2 &lt; line1) {
      fprintf(stderr, "bis-Zeile kann nicht "
                      "gr&ouml;sser sein, wie von-Zeile!\n");
      return EXIT_FAILURE;
   }
   linenr=getsline_number(line1,line2, f);
   if(linenr == NULL) {
      fprintf(stderr, "Fehler beim Lesen "
                      "der %d-ten Zeile??\n",i);
      return EXIT_FAILURE;
   }
   printf("\n");
   return EXIT_SUCCESS;
}</pre>
<h4 class="t4">Wie kann ich alle Zeilen ausgeben, die eine bestimmte Stringfolge enthalten<a id="Xxx999388" name="Xxx999388"></a>?</h4>
<pre>/* search_string.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define BUF 255
int main(int argc, char **argv) {
   FILE *f;
   char searchstring[BUF], puffer[BUF];
   int counter = 1;
   if(argc &lt; 2) {
      fprintf(stderr, "Verwendung : %s datei\n", *argv);
      return EXIT_FAILURE;
   }
   f = fopen(argv[1], "r");
   if(f == NULL) {
      printf("Fehler bei fopen()... \n");
      return EXIT_FAILURE;
   }
   printf("Wonach suchen Sie in %s : ", argv[1]);
   scanf("%s", searchstring);
   printf("\n");
   while( fgets(puffer, BUF, f) != NULL ) {
      if(strstr(puffer,searchstring) != 0)
         printf("Zeile %d : %s",counter,puffer);
      counter++;
   }
   printf("\n");
   return EXIT_SUCCESS;
}</pre>
<p>Der Nachteil an diesem Beispiel ist, dass <span class="listing">strstr()</span> praktisch alle Stringfolgen ausgibt. Suchen Sie beispielsweise nach der Stringfolge »int«, dann gibt <span class="listing">strstr()</span> auch »wahr« aus, wenn die Folge »printf«, »fprintf«, »Lint«, »Mint« … lautet. Wenn dies so gewollt ist, dann ist es in Ordnung. Falls nicht, muss mit <span class="listing">strtok()</span> ein Worttrenner eingebaut werden.</p>
<h4 class="t4">Wie kann ich alle Zeilen ausgeben, die ein bestimmtes Wort enthalten<a id="Xxx999392" name="Xxx999392"></a>?</h4>
<pre>/* search_word.c */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define BUF 255
/* Anpassen nach Bedarf... */
const char trennzeichen[] = ".;,:\"\' ";
int main(int argc, char **argv) {
   FILE *f;
   char searchstring[BUF];
   char puffer[BUF], puffer_bak[BUF];
   int counter=1;
   char *wort;
   if(argc &lt; 2) {
      fprintf(stderr, "Verwendung : %s datei\n",*argv);
      return EXIT_FAILURE;
      }
   f=fopen(argv[1],"r");
   if(f == NULL) {
      printf("Fehler bei fopen()...");
      return EXIT_FAILURE;
   }
   printf("Wonach suchen Sie in %s : ",argv[1]);
   scanf("%s", searchstring);
   printf("\n");
   while(fgets(puffer, BUF, f) != NULL) {
      strcpy(puffer_bak, puffer);
      wort = strtok(puffer, trennzeichen);
      while(wort != NULL) {
         if(strcmp(wort,searchstring) == 0)
            printf("Zeile %d : %s",counter,puffer_bak);
         wort = strtok(NULL,trennzeichen);
      }
      counter++;
   }
   printf("\n");
   return EXIT_SUCCESS;
}</pre>
<h4 class="t4">Suchen und Ersetzen in einer Textdatei (nur ganze Worte, keine Teilstrings<a id="Xxx999395" name="Xxx999395"></a>)</h4>
<pre>/* search_and_replace.c */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#define STRING_MAX 8192
int wort_begrenzer(char c) {
   return (c == ' ' || c == '\n' || c == '\t' || c == '\0' ||
       c == '.' || c == ',' || c == ';' || c == '!' ||c == '?');
}
/* Newline von fgets() entfernen */
void chomp(char *str) {
 size_t p=strlen(str);
 str[p-1] = '\0';
}
int main(int argc, char **argv) {
   FILE *file, *copy;
   char alt_string[STRING_MAX+1],neu_string[STRING_MAX+1],
        such_wort[STRING_MAX+1],replace_wort[STRING_MAX+1],
        *zgr;
   char puffer[STRING_MAX+1];
   int such_wortlen, i=0,w;
   size_t len=0;
   if(argc &lt; 2) {
      fprintf(stderr, "Verwendung: %s datei\n", *argv);
      return EXIT_FAILURE;
   }
   file = fopen(argv[1],"r");   /* Datei zum Lesen &ouml;ffnen     */
   copy = fopen(argv[1],"r+");  /* Datei zum Schreiben &ouml;ffnen */
   if(file == NULL || copy == NULL) {
      printf("Fehler bei fopen()...\n");
      return EXIT_FAILURE;
   }
   alt_string[0]='\0';
   /* Kompletten String in alt_string legen ... */
   /* Bitte ggf. selbst durch dynamische Speicherverwaltung
     * gen&uuml;gend Platz schaffen! */
   while( (fgets(puffer,STRING_MAX+1,file)) != NULL ) {
      len += strlen(puffer)+1;
      if(len &lt; STRING_MAX)
         strcat(alt_string, puffer);
      else {
         printf("Puffergroesse ueberschritten!\n");
         break;
      }
   }
   neu_string[0]='\0';
   printf("Welches Wort wollen Sie ersetzen : ");
   fgets(such_wort, STRING_MAX, stdin );
   chomp(such_wort);
   such_wortlen = strlen(such_wort); /* L&auml;nge des Suchwortes */
   for(w = 0; w &lt; such_wortlen; w++)
   /* Nach Wortbegrenzern duchlaufen ... */
   if(wort_begrenzer(such_wort[w])) {
      printf("Keine Wortbegrenzer im Suchwort!!!\n");
      return EXIT_FAILURE;
   }
   printf("Durch welches Wort wollen Sie ersetzen : ");
   fgets(replace_wort, STRING_MAX, stdin);
   chomp(replace_wort);
   i = 0;
   while(1){
      if( (zgr=strstr(&amp;alt_string[i], such_wort)) == NULL) {
         /* Kein Wort zu ersetzen */
         strcat(neu_string, &amp;alt_string[i]);
         break;
      }
      else { /*..ansonsten von Byte i bis zgr in neu_string*/
         strncat(neu_string, &amp;alt_string[i], zgr-&amp;alt_string[i]);
         /* Jetzt &uuml;berpr&uuml;fen, ob wir ein Wort haben und
          * keinen Teilstring oder das Wort am Anfang steht */
         if( (zgr-&amp;alt_string[0]==0 ||
              wort_begrenzer( *(zgr-1))) &amp;&amp;
              wort_begrenzer( *(zgr+such_wortlen))) {
            strcat(neu_string, replace_wort);
            /* Nach ersetztem Wort den Zeiger setzen ... */
            i += zgr + such_wortlen-&amp;alt_string[i];
         }
         else {
            strncat(neu_string, zgr, 1);
            i += zgr + 1-&amp;alt_string[i];
         }
      }
   } /* Ende while(1) */
   /* F&uuml;r Testausgabe ... */
   /* printf("Neuer String : %s\n",neu_string); */
   strcpy(alt_string, neu_string);
   /* Achtung jetzt wirds ernst,
    * f&uuml;r Testausgabe in Kommentar setzen*/
   fputs(alt_string, copy);
   neu_string[0] = '\0';
   return EXIT_SUCCESS;
}</pre>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td width="100%" class="start" colspan="1" height="22" align="center">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="25%"><a class="navnav" href="c_018_014.htm"> &lt;&lt; zur&uuml;ck</a></td>
<td width="49%">
<div align="center"><a class="navnav" href="#">&lt;top&gt;</a></div>
</td>
<td align="right" width="25%">
<div align="right"><a class="navnav" href="c_018_016.htm">vor &gt;&gt; </a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
</td>
<td width="10" valign="top">&nbsp;&nbsp;</td>
<td width="160" valign="top">
    <table border="0" cellpadding="0" cellspacing="0" width="160">
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">
                            &nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opc" class="navs">
                            <strong>Zum Katalog</strong></a>
                        </td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2">
                            <img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><a href="http://www.galileocomputing.de/899?GPP=opc">
                                        <img src="common/643_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C von A bis Z" title="Zum Katalog: C von A bis Z">
                                        <br /><strong>C von A bis Z</strong><br /><img src="common/pfeil_rechts5.gif" border="0" alt="">bestellen</a>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Ihre Meinung?</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td>Wie hat Ihnen das &lt;openbook&gt; gefallen?<br /><a href="mailto:stefan.krumbiegel@galileo-press.de?subject=Meinung%20zu%20C%20von%20A%20bis%20Z%20(openbook)"><img src="common/pfeil_rechts5.gif" border="0" alt="">Ihre Meinung</a>
                                    <br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2">&nbsp;<a href="http://www.galileocomputing.de/katalog/buecher/?GPP=opc" class="navs"><strong>Buchtipps</strong></a></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1007?GPP=opc">
                        <img src="common/683_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Shell-Programmierung" title="Zum Katalog: Shell-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Shell-Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1137?GPP=opc">
                        <img src="common/749_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux-UNIX-Programmierung" title="Zum Katalog: Linux-UNIX-Programmierung"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux-UNIX-Programmierung</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/1004?GPP=opc">
                        <img src="common/644_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: C/C++" title="Zum Katalog: C/C++"><br /><br /><br /><br /><br /><br /><br />&nbsp;C/C++</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/880?GPP=opc">
                        <img src="common/573_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: UML 2.0" title="Zum Katalog: UML 2.0"><br /><br /><br /><br /><br /><br /><br />&nbsp;UML 2.0</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/967?GPP=opc">
                        <img src="common/626_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Reguläre Ausdrücke" title="Zum Katalog: Reguläre Ausdrücke"><br /><br /><br /><br /><br /><br /><br />&nbsp;Reguläre Ausdrücke</a><br /><br /></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td><td valign="top">
                        <a href="http://www.galileocomputing.de/941?GPP=opc">
                        <img src="common/677_90px.gif" width="105" height="90" border="0" align="left" hspace="4" vspace="8" alt="Zum Katalog: Linux" title="Zum Katalog: Linux"><br /><br /><br /><br /><br /><br /><br />&nbsp;Linux</a><br /><br /></td>
                    </tr>
                </table></td>
        </tr>
        <tr>
            <td><img src="common/leer.gif" height="2" width="1" border="0" /></td>
        </tr>
        <tr>
            <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%">
                    <tr>
                        <td class="tbl2" height="20" colspan="2"><strong>&nbsp;Shopping</strong></td>
                    </tr>
                    <tr>
                        <td valign="top" class="tbl2" width="2"><img src="common/leer.gif" border="0" height="1" width="1"></td>
                        <td valign="top">
                            <table cellspacing="3">
                                <tr>
                                    <td><b>Versandkostenfrei</b> bestellen in Deutschland und &Ouml;sterreich<br /><a href="http://www.galileocomputing.de/hilfe/Shop/?GPP=opc"><img src="common/pfeil_rechts5.gif" border="0" alt="Info">Info</a><br /><br /></td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                </table>
            </td>
        </tr>
    </table>
</td>
</tr>
</table>
<br /><br />
<hr width="70%" align="center"><br />
<div align="center">
<p class="standard"><b>Copyright © Galileo Press 2006</b><br>F&uuml;r Ihren privaten Gebrauch d&uuml;rfen Sie die Online-Version nat&uuml;rlich ausdrucken. Ansonsten unterliegt das &lt;openbook&gt; denselben Bestimmungen, wie die gebundene Ausgabe: Das Werk einschlie&szlig;lich aller seiner Teile ist urheberrechtlich gesch&uuml;tzt. Alle Rechte vorbehalten einschlie&szlig;lich der Vervielf&auml;ltigung, &Uuml;bersetzung, Mikroverfilmung sowie Einspeicherung und Verarbeitung in elektronischen Systemen.</p><br><a href="http://www.galileocomputing.de/">[Galileo Computing]</a><br><br>Galileo Press, Rheinwerkallee 4, 53227 Bonn, Tel.: 0228.42150.0, Fax 0228.42150.77, <a href="mailto:info@galileo-press.de">info@galileo-press.de</a></div><br><br></body>
</html>
